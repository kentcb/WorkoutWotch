// -----------------------------------------------------------------------
// <autogenerated>
//    This code was generated from a template.
// 
//    Changes to this file may cause incorrect behaviour and will be lost
//    if the code is regenerated.
// </autogenerated>
// ------------------------------------------------------------------------
namespace WorkoutWotch.UnitTests.Services.Analytics.Mocks
{
    [System.CodeDom.Compiler.GeneratedCode("PCLMock", "3.1.2.0")]
    [System.Runtime.CompilerServices.CompilerGenerated]
    public partial class AnalyticsServiceMock : global::Kent.Boogaart.PCLMock.MockBase<global::WorkoutWotch.Services.Contracts.Analytics.IAnalyticsService>, global::WorkoutWotch.Services.Contracts.Analytics.IAnalyticsService
    {
        public AnalyticsServiceMock(global::Kent.Boogaart.PCLMock.MockBehavior behavior = global::Kent.Boogaart.PCLMock.MockBehavior.Strict): base (behavior)
        {
            if ((behavior) == (global::Kent.Boogaart.PCLMock.MockBehavior.Loose))
            {
                ConfigureLooseBehavior();
            }
        }

        partial void ConfigureLooseBehavior();
        public void Identify(System.String userId, global::System.Collections.Generic.IDictionary<System.String, System.String> metadata)
        {
            this.Apply(x => x.Identify(userId, metadata));
        }

        public void Track(System.String id, global::System.Collections.Generic.IDictionary<System.String, System.String> metadata)
        {
            this.Apply(x => x.Track(id, metadata));
        }

        public global::System.IDisposable TrackTime(System.String id, global::System.Collections.Generic.IDictionary<System.String, System.String> metadata)
        {
            return this.Apply(x => x.TrackTime(id, metadata));
        }

        public void RecordException(global::System.Exception exception, global::WorkoutWotch.Services.Contracts.Analytics.ExceptionLevel exceptionLevel, global::System.Collections.IDictionary metadata)
        {
            this.Apply(x => x.RecordException(exception, exceptionLevel, metadata));
        }
    }
}
namespace WorkoutWotch.UnitTests.Services.Logger.Mocks
{
    [System.CodeDom.Compiler.GeneratedCode("PCLMock", "3.1.2.0")]
    [System.Runtime.CompilerServices.CompilerGenerated]
    public partial class LoggerServiceMock : global::Kent.Boogaart.PCLMock.MockBase<global::WorkoutWotch.Services.Contracts.Logger.ILoggerService>, global::WorkoutWotch.Services.Contracts.Logger.ILoggerService
    {
        public LoggerServiceMock(global::Kent.Boogaart.PCLMock.MockBehavior behavior = global::Kent.Boogaart.PCLMock.MockBehavior.Strict): base (behavior)
        {
            if ((behavior) == (global::Kent.Boogaart.PCLMock.MockBehavior.Loose))
            {
                ConfigureLooseBehavior();
            }
        }

        partial void ConfigureLooseBehavior();
        public global::WorkoutWotch.Services.Contracts.Logger.LogLevel Threshold
        {
            get
            {
                return this.Apply(x => x.Threshold);
            }

            set
            {
                this.ApplyPropertySet(x => x.Threshold, value);
            }
        }

        public System.Boolean IsDebugEnabled
        {
            get
            {
                return this.Apply(x => x.IsDebugEnabled);
            }
        }

        public System.Boolean IsInfoEnabled
        {
            get
            {
                return this.Apply(x => x.IsInfoEnabled);
            }
        }

        public System.Boolean IsPerfEnabled
        {
            get
            {
                return this.Apply(x => x.IsPerfEnabled);
            }
        }

        public System.Boolean IsWarnEnabled
        {
            get
            {
                return this.Apply(x => x.IsWarnEnabled);
            }
        }

        public System.Boolean IsErrorEnabled
        {
            get
            {
                return this.Apply(x => x.IsErrorEnabled);
            }
        }

        public global::System.IObservable<global::WorkoutWotch.Services.Contracts.Logger.LogEntry> Entries
        {
            get
            {
                return this.Apply(x => x.Entries);
            }
        }

        public global::WorkoutWotch.Services.Contracts.Logger.ILogger GetLogger(global::System.Type forType)
        {
            return this.Apply(x => x.GetLogger(forType));
        }

        public global::WorkoutWotch.Services.Contracts.Logger.ILogger GetLogger(System.String name)
        {
            return this.Apply(x => x.GetLogger(name));
        }
    }
}
namespace WorkoutWotch.UnitTests.Services.Logger.Mocks
{
    [System.CodeDom.Compiler.GeneratedCode("PCLMock", "3.1.2.0")]
    [System.Runtime.CompilerServices.CompilerGenerated]
    public partial class LoggerMock : global::Kent.Boogaart.PCLMock.MockBase<global::WorkoutWotch.Services.Contracts.Logger.ILogger>, global::WorkoutWotch.Services.Contracts.Logger.ILogger
    {
        public LoggerMock(global::Kent.Boogaart.PCLMock.MockBehavior behavior = global::Kent.Boogaart.PCLMock.MockBehavior.Strict): base (behavior)
        {
            if ((behavior) == (global::Kent.Boogaart.PCLMock.MockBehavior.Loose))
            {
                ConfigureLooseBehavior();
            }
        }

        partial void ConfigureLooseBehavior();
        public System.String Name
        {
            get
            {
                return this.Apply(x => x.Name);
            }
        }

        public System.Boolean IsDebugEnabled
        {
            get
            {
                return this.Apply(x => x.IsDebugEnabled);
            }
        }

        public System.Boolean IsInfoEnabled
        {
            get
            {
                return this.Apply(x => x.IsInfoEnabled);
            }
        }

        public System.Boolean IsPerfEnabled
        {
            get
            {
                return this.Apply(x => x.IsPerfEnabled);
            }
        }

        public System.Boolean IsWarnEnabled
        {
            get
            {
                return this.Apply(x => x.IsWarnEnabled);
            }
        }

        public System.Boolean IsErrorEnabled
        {
            get
            {
                return this.Apply(x => x.IsErrorEnabled);
            }
        }

        public void Debug(System.String message)
        {
            this.Apply(x => x.Debug(message));
        }

        public void Debug(System.String format, System.Object[] args)
        {
            this.Apply(x => x.Debug(format, args));
        }

        public void Debug(global::System.Exception exception, System.String format, System.Object[] args)
        {
            this.Apply(x => x.Debug(exception, format, args));
        }

        public void Info(System.String message)
        {
            this.Apply(x => x.Info(message));
        }

        public void Info(System.String format, System.Object[] args)
        {
            this.Apply(x => x.Info(format, args));
        }

        public void Info(global::System.Exception exception, System.String format, System.Object[] args)
        {
            this.Apply(x => x.Info(exception, format, args));
        }

        public global::System.IDisposable Perf(System.String message)
        {
            return this.Apply(x => x.Perf(message));
        }

        public global::System.IDisposable Perf(System.String format, System.Object[] args)
        {
            return this.Apply(x => x.Perf(format, args));
        }

        public void Warn(System.String message)
        {
            this.Apply(x => x.Warn(message));
        }

        public void Warn(System.String format, System.Object[] args)
        {
            this.Apply(x => x.Warn(format, args));
        }

        public void Warn(global::System.Exception exception, System.String format, System.Object[] args)
        {
            this.Apply(x => x.Warn(exception, format, args));
        }

        public void Error(System.String message)
        {
            this.Apply(x => x.Error(message));
        }

        public void Error(System.String format, System.Object[] args)
        {
            this.Apply(x => x.Error(format, args));
        }

        public void Error(global::System.Exception exception, System.String format, System.Object[] args)
        {
            this.Apply(x => x.Error(exception, format, args));
        }
    }
}
namespace WorkoutWotch.UnitTests.Services.Scheduler.Mocks
{
    [System.CodeDom.Compiler.GeneratedCode("PCLMock", "3.1.2.0")]
    [System.Runtime.CompilerServices.CompilerGenerated]
    public partial class SchedulerServiceMock : global::Kent.Boogaart.PCLMock.MockBase<global::WorkoutWotch.Services.Contracts.Scheduler.ISchedulerService>, global::WorkoutWotch.Services.Contracts.Scheduler.ISchedulerService
    {
        public SchedulerServiceMock(global::Kent.Boogaart.PCLMock.MockBehavior behavior = global::Kent.Boogaart.PCLMock.MockBehavior.Strict): base (behavior)
        {
            if ((behavior) == (global::Kent.Boogaart.PCLMock.MockBehavior.Loose))
            {
                ConfigureLooseBehavior();
            }
        }

        partial void ConfigureLooseBehavior();
        public global::System.Reactive.Concurrency.IScheduler DefaultScheduler
        {
            get
            {
                return this.Apply(x => x.DefaultScheduler);
            }
        }

        public global::System.Reactive.Concurrency.IScheduler CurrentThreadScheduler
        {
            get
            {
                return this.Apply(x => x.CurrentThreadScheduler);
            }
        }

        public global::System.Reactive.Concurrency.IScheduler ImmediateScheduler
        {
            get
            {
                return this.Apply(x => x.ImmediateScheduler);
            }
        }

        public global::System.Reactive.Concurrency.IScheduler MainScheduler
        {
            get
            {
                return this.Apply(x => x.MainScheduler);
            }
        }

        public global::System.Reactive.Concurrency.IScheduler TaskPoolScheduler
        {
            get
            {
                return this.Apply(x => x.TaskPoolScheduler);
            }
        }
    }
}
namespace WorkoutWotch.UnitTests.Services.State.Mocks
{
    [System.CodeDom.Compiler.GeneratedCode("PCLMock", "3.1.2.0")]
    [System.Runtime.CompilerServices.CompilerGenerated]
    public partial class StateServiceMock : global::Kent.Boogaart.PCLMock.MockBase<global::WorkoutWotch.Services.Contracts.State.IStateService>, global::WorkoutWotch.Services.Contracts.State.IStateService
    {
        public StateServiceMock(global::Kent.Boogaart.PCLMock.MockBehavior behavior = global::Kent.Boogaart.PCLMock.MockBehavior.Strict): base (behavior)
        {
            if ((behavior) == (global::Kent.Boogaart.PCLMock.MockBehavior.Loose))
            {
                ConfigureLooseBehavior();
            }
        }

        partial void ConfigureLooseBehavior();
        public global::System.IObservable<T> GetAsync<T>(System.String key)
        {
            return this.Apply(x => x.GetAsync<T>(key));
        }

        public global::System.IObservable<global::System.Reactive.Unit> SetAsync<T>(System.String key, T value)
        {
            return this.Apply(x => x.SetAsync<T>(key, value));
        }

        public global::System.IObservable<global::System.Reactive.Unit> RemoveAsync<T>(System.String key)
        {
            return this.Apply(x => x.RemoveAsync<T>(key));
        }

        public global::System.IObservable<global::System.Reactive.Unit> SaveAsync()
        {
            return this.Apply(x => x.SaveAsync());
        }

        public global::System.IDisposable RegisterSaveCallback(global::WorkoutWotch.Services.Contracts.State.SaveCallback saveCallback)
        {
            return this.Apply(x => x.RegisterSaveCallback(saveCallback));
        }
    }
}
namespace WorkoutWotch.UnitTests.Services.Delay.Mocks
{
    [System.CodeDom.Compiler.GeneratedCode("PCLMock", "3.1.2.0")]
    [System.Runtime.CompilerServices.CompilerGenerated]
    public partial class DelayServiceMock : global::Kent.Boogaart.PCLMock.MockBase<global::WorkoutWotch.Services.Contracts.Delay.IDelayService>, global::WorkoutWotch.Services.Contracts.Delay.IDelayService
    {
        public DelayServiceMock(global::Kent.Boogaart.PCLMock.MockBehavior behavior = global::Kent.Boogaart.PCLMock.MockBehavior.Strict): base (behavior)
        {
            if ((behavior) == (global::Kent.Boogaart.PCLMock.MockBehavior.Loose))
            {
                ConfigureLooseBehavior();
            }
        }

        partial void ConfigureLooseBehavior();
        public global::System.IObservable<global::System.Reactive.Unit> DelayAsync(global::System.TimeSpan duration, global::System.Threading.CancellationToken cancellationToken)
        {
            return this.Apply(x => x.DelayAsync(duration, cancellationToken));
        }
    }
}
namespace WorkoutWotch.UnitTests.Services.ExerciseDocument.Mocks
{
    [System.CodeDom.Compiler.GeneratedCode("PCLMock", "3.1.2.0")]
    [System.Runtime.CompilerServices.CompilerGenerated]
    public partial class ExerciseDocumentServiceMock : global::Kent.Boogaart.PCLMock.MockBase<global::WorkoutWotch.Services.Contracts.ExerciseDocument.IExerciseDocumentService>, global::WorkoutWotch.Services.Contracts.ExerciseDocument.IExerciseDocumentService
    {
        public ExerciseDocumentServiceMock(global::Kent.Boogaart.PCLMock.MockBehavior behavior = global::Kent.Boogaart.PCLMock.MockBehavior.Strict): base (behavior)
        {
            if ((behavior) == (global::Kent.Boogaart.PCLMock.MockBehavior.Loose))
            {
                ConfigureLooseBehavior();
            }
        }

        partial void ConfigureLooseBehavior();
        public global::System.IObservable<System.String> ExerciseDocument
        {
            get
            {
                return this.Apply(x => x.ExerciseDocument);
            }
        }
    }
}
namespace WorkoutWotch.UnitTests.Services.Audio.Mocks
{
    [System.CodeDom.Compiler.GeneratedCode("PCLMock", "3.1.2.0")]
    [System.Runtime.CompilerServices.CompilerGenerated]
    public partial class AudioServiceMock : global::Kent.Boogaart.PCLMock.MockBase<global::WorkoutWotch.Services.Contracts.Audio.IAudioService>, global::WorkoutWotch.Services.Contracts.Audio.IAudioService
    {
        public AudioServiceMock(global::Kent.Boogaart.PCLMock.MockBehavior behavior = global::Kent.Boogaart.PCLMock.MockBehavior.Strict): base (behavior)
        {
            if ((behavior) == (global::Kent.Boogaart.PCLMock.MockBehavior.Loose))
            {
                ConfigureLooseBehavior();
            }
        }

        partial void ConfigureLooseBehavior();
        public global::System.IObservable<global::System.Reactive.Unit> PlayAsync(System.String name)
        {
            return this.Apply(x => x.PlayAsync(name));
        }
    }
}
namespace WorkoutWotch.UnitTests.Services.Speech.Mocks
{
    [System.CodeDom.Compiler.GeneratedCode("PCLMock", "3.1.2.0")]
    [System.Runtime.CompilerServices.CompilerGenerated]
    public partial class SpeechServiceMock : global::Kent.Boogaart.PCLMock.MockBase<global::WorkoutWotch.Services.Contracts.Speech.ISpeechService>, global::WorkoutWotch.Services.Contracts.Speech.ISpeechService
    {
        public SpeechServiceMock(global::Kent.Boogaart.PCLMock.MockBehavior behavior = global::Kent.Boogaart.PCLMock.MockBehavior.Strict): base (behavior)
        {
            if ((behavior) == (global::Kent.Boogaart.PCLMock.MockBehavior.Loose))
            {
                ConfigureLooseBehavior();
            }
        }

        partial void ConfigureLooseBehavior();
        public global::System.IObservable<global::System.Reactive.Unit> SpeakAsync(System.String speechString, global::System.Threading.CancellationToken cancellationToken)
        {
            return this.Apply(x => x.SpeakAsync(speechString, cancellationToken));
        }
    }
}
namespace WorkoutWotch.UnitTests.Models.Mocks
{
    [System.CodeDom.Compiler.GeneratedCode("PCLMock", "3.1.2.0")]
    [System.Runtime.CompilerServices.CompilerGenerated]
    public partial class ActionMock : global::Kent.Boogaart.PCLMock.MockBase<global::WorkoutWotch.Models.IAction>, global::WorkoutWotch.Models.IAction
    {
        public ActionMock(global::Kent.Boogaart.PCLMock.MockBehavior behavior = global::Kent.Boogaart.PCLMock.MockBehavior.Strict): base (behavior)
        {
            if ((behavior) == (global::Kent.Boogaart.PCLMock.MockBehavior.Loose))
            {
                ConfigureLooseBehavior();
            }
        }

        partial void ConfigureLooseBehavior();
        public global::System.TimeSpan Duration
        {
            get
            {
                return this.Apply(x => x.Duration);
            }
        }

        public global::System.IObservable<global::System.Reactive.Unit> ExecuteAsync(global::WorkoutWotch.Models.ExecutionContext context)
        {
            return this.Apply(x => x.ExecuteAsync(context));
        }
    }
}
namespace WorkoutWotch.UnitTests.Models.Mocks
{
    [System.CodeDom.Compiler.GeneratedCode("PCLMock", "3.1.2.0")]
    [System.Runtime.CompilerServices.CompilerGenerated]
    public partial class EventMock : global::Kent.Boogaart.PCLMock.MockBase<global::WorkoutWotch.Models.IEvent>, global::WorkoutWotch.Models.IEvent
    {
        public EventMock(global::Kent.Boogaart.PCLMock.MockBehavior behavior = global::Kent.Boogaart.PCLMock.MockBehavior.Strict): base (behavior)
        {
            if ((behavior) == (global::Kent.Boogaart.PCLMock.MockBehavior.Loose))
            {
                ConfigureLooseBehavior();
            }
        }

        partial void ConfigureLooseBehavior();
        public global::WorkoutWotch.Models.ExecutionContext ExecutionContext
        {
            get
            {
                return this.Apply(x => x.ExecutionContext);
            }
        }
    }
}
namespace WorkoutWotch.UnitTests.Models.Mocks
{
    [System.CodeDom.Compiler.GeneratedCode("PCLMock", "3.1.2.0")]
    [System.Runtime.CompilerServices.CompilerGenerated]
    public partial class EventMatcherMock : global::Kent.Boogaart.PCLMock.MockBase<global::WorkoutWotch.Models.IEventMatcher>, global::WorkoutWotch.Models.IEventMatcher
    {
        public EventMatcherMock(global::Kent.Boogaart.PCLMock.MockBehavior behavior = global::Kent.Boogaart.PCLMock.MockBehavior.Strict): base (behavior)
        {
            if ((behavior) == (global::Kent.Boogaart.PCLMock.MockBehavior.Loose))
            {
                ConfigureLooseBehavior();
            }
        }

        partial void ConfigureLooseBehavior();
        public System.Boolean Matches(global::WorkoutWotch.Models.IEvent @event)
        {
            return this.Apply(x => x.Matches(@event));
        }
    }
}

